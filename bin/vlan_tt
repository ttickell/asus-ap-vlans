#!/bin/sh
## vlan_tt - VLANs Take Two
[ -z "$VLAN_TT_TESTING" ] && VLAN_TT_TESTING=0
## This script is meant for use on Asus routers running in access point mode.
##  Any other use may remove your node from the networ ... or worse.
##
## for full details please see README.md

## Do things a bit differently if we are testing
##
## Set the environment vairable VLAN_TT_TESTING to 1 to enable testing mode
if [ "$VLAN_TT_TESTING" -eq 1 ]; then
	base="/tmp/mnt/ENTWARE/asus-ap-vlans-tt"
else
	base="/jffs/local"
fi

## Where are our configiguration files?
## 
## default location is /jffs/local/etc/vlan_tt.d but this may be overriden by
##  setting the environment variable VLAN_TT_CONFIG_DIR
if [ ! -z "$VLAN_TT_CONFIG_DIR" ]; then
	etc="$VLAN_TT_CONFIG_DIR"
else
	etc="$base/etc"
fi

## Name top bue used as tag when logging to Syslog
myname=$(basename "$0")

## Logging 
## 
## message - log the things we normally want to see
## message <message to log>
message() {
	[ "$VLAN_TT_TESTING" -eq 1 ] && echo "INFO: $@" 1>&2
	logger -t "$myname" -p user.notice "$@"
}

## error - log the things that didn't go as planned
##
## error <error message>
error() {
	[ "$VLAN_TT_TESTING" -eq 1 ] && echo "ERROR: $@" 1>&2
	logger -t "$myname" -p user.error "$@"
}

## Debug - log the things we need to figure out why things didn't go as planned
##
## debug <debug message>
debug() {
	[ "$VLAN_TT_TESTING" -eq 1 ] && echo "DEBUG: $@" 1>&2
	logger -t "$myname" -p user.debug "$@"
}

## Command Log - stream of things we actually udpated on the router
##
## command_log <command>
command_log(){
	[ "$VLAN_TT_TESTING" -eq 1 ] && echo "COMMAND: $@" 1>&2
	logger -t "$myname" -p user.info "$@"
}

## Log the execution and result of a command, return SUCCESS on sucessa and FAIL on fail.
## 
## Additioanlly returns values of 0 on success and 1 on failure
##
## Note - this is not perfect - some commands need better handling, noteably
## the eapd restart. Where possible, those are logged 
## 
## command_execute <command>
command_execute(){
	local command="$1"
	local output
	local res

	debug "command_execute called with \"$command\""
	command_log "$command"
	output=$($command 2>&1)
	res=$?
	debug "command output:"
	debug "$output"
	if [ "$res" -gt 0 ]; then
		echo "FAIL"
		return 1
	else
		echo "SUCCESS"
		return 0
	fi
}

make_lan_ifname(){
	local bridge="$1"
	local lan

	if [ -z "$bridge" ]; then
		error "make_lan_ifname : bridge opt is required"
		echo "FAIL"
		exit 1
	fi
	# br0 maps to lan_ifnames, not lan0 ifnames
	if [ "$bridge" == "br0" ]; then
		lan="lan"
	else
		lan=$(echo $bridge | sed -e 's/br/lan/')
	fi
	echo $lan
	return 0
}
## Determine if a bridge exists
##
## before we make a bridge, we need to know if it already exists
##
## bridge_exists <bridge name>
bridge_exists(){
	local bridge="$1"
	local output
	local res

	# Different versions of brctl respond differently
	#  with error conditions	
	output=$(brctl show $bridge 2>&1)
	res=$?
	# brctl 1.6 returns error when bridge does not exist
	if [ "$res" -gt 1 ]; then
		echo "FALSE"
		return 1
	fi
	# brctl 1.5 (and presumably lower, no output device) returns0
	#  but logs an error
	output=$(echo "${output}" | grep "No such device")
	res=$?
	if [ "$res" -eq 0 ]; then
		echo "FALSE"
		return 1
	fi
	echo "TRUE"
	return 0
}

## Create a bridge
##
## if we need a bridge that doesn't exist, make one.
## 
## bridge_create <bridge name>
bridge_create(){
	local bridge="$1"

	debug "bridge_create called with $bridge"
	if [ -z "$bridge" ]; then
		error  "bridge_create : option1 must be bridge name, cannot be null"
		echo "FAIL" 
		return
	fi
	echo $(command_execute "brctl addbr $bridge")
}

## Get a list of existing bridges
## 
## Simple and direct-just parrse out the names of all the bridge we have
##
## bridge_list
bridge_list(){
	local list
	list=$(brctl show | grep '^br[0-9]' | awk '{print $1}' | tr '\n' ' ')
	echo $list
	return 0
}

## Check if an interface is in a bridge
## 
## for any given bridge and interface, check to see if that interface
##  is already in the bridge
##
## bridge_has_int <bridge> <interface>
bridge_has_int(){
	local bridge="$1"
	local int="$2"
	local output
	local res

	debug "bridge_has_int : Checking for $int in $bridge"
	output=$(brctl show $bridge 2>&1 | grep $int)
	res=$?
	if [ "$res" -gt 0 ]; then
		echo "FALSE"
	else 
		echo "TRUE"
	fi
}

## Configuration of a port list is comma deliomited, may have spaces, etc.
##
## Clean them up.
##
## normalize_ports <port list>
normalize_ports(){
	local list="$1"

	list=$(echo $list | sed -e 's/[[:space:]]//g;s/,/ /g')
	echo "$list"
}

## Create a tagged interface
##
## This creates the virutal ethernet interface asociated with a spepific VLAN
##
## If the interface already exists, it will be left alone.
##
## tagged_interface_create <interface> <vlan>
tagged_interface_create(){
	local int="$1"
	local vlan="$2"
	local output
	local res
	local tagged_int

	## Did we get the options we need to run?
	if [ -z "$int" -o -z "$vlan" ]; then
		error "tagged_interface_create : int and vlan cannot be null - got \"$int\" and \"$vlan\""
		echo "FAIL"
		return 1
	fi
	debug "tagged_inteface create : working with int $int on vlan $vlan"
	## The name of each interface is <real>.<vlan> - ie. eth1.500 would be VLAN 500 on eth1
	tagged_int="${int}.${vlan}"
	output=$(ip link show $tagged_int 2>&1)
	res=$?
	## Error in an ip link show means the interface doesn't exist and we need to create it
	if [ "$res" -gt 0 ]; then
		debug "tagged_interface_create : $tagged_int does not seem to exist.  Creating"
		output=$(command_execute "ip link add link ${int} name ${tagged_int} type vlan id ${vlan}")
		if [ "$output" == "FAIL" ]; then
			error "tagged_interface_create : Error creating $tagged_int"
			echo "FAIL"
			return 1
		fi

		## After creaton, the interface must be marked up for use
		debug "tagged_interface_create : setting $tagged_int up"
		output=$(command_execute "ip link set ${tagged_int} up")
		if [ "$output" == "FAIL" ]; then
			error "tagged_interface_create : Error bringing $tagged_int online"
			echo "FAIL"
			return 1
		fi
	fi
	echo "SUCESS"
	return 0
}

lan_ifnames_reset(){
	local bridge="$1"
	local lan
	local output	
	
	debug "lan_ifnames_reset : called for $bridge"

	lan=$(make_lan_ifname "$bridge")
	if [ "$lan" == "FAIL" ]; then
		error "lan_ifnames_reset : make_lan_ifname failed on $bridge"
	fi
	
	output=$(bridge_get_ints "$bridge")
	debug "lan_ifnames_reset : reseting ${lan}_ifnames to \"$output\""	
	command_log "nvram set ${lan}_ifnames=\"$output\""
	nvram set ${lan}_ifnames="$output"

}
	

## bridge_add_int bridge int
##
## Add and interface to a bridge.  If the interface is already in another bridge, it will be removed	
## 
## bridge_add_int <bridge> <interface>		
bridge_add_int(){
	local bridge="$1"
	local int="$2"
	local output
	local res
	local list
	local cur_br
	debug "bridge_add_int : ------------------------------------------------------"
	debug "bridge_add_int : called with bridge \"$bridge\" and int \"$int\""

	## make sure we have what we need
	if [ -z "$bridge" -o -z "$int" ]; then 
		error "bridge_add_int : bridge and int must be specified"
		echo "FAIL"
		return 1
	fi

	## if we already ahve the int in bridge, we are done
	output=$(bridge_has_int "$bridge" "$int")
	if [ "$output" == "TRUE" ]; then
		debug "bridge_add_int : Int \"$int\" is already in \"$bridge\" - returning"
		echo "NOCHANGE"
		return 0
	fi

	## get a list of bridges and remove the int from all of them	
	list=$(bridge_list)
	for cur_br in $list; do
		debug "bridge_add_int : looking at bridge $cur_br to see if $int needs to be removed"
		if [ "$cur_br" == "$bridge" ]; then
			## This is the one we want in there and we already know it's not
			##  becase we didn't return, above.
			debug "bridge_add_int : skipping $cur_br for $int removal because it matches desired bridge $bridge"
			continue
		fi
		## if this is a member of another bridge, remove it	
		output=$(bridge_has_int "$cur_br" "$int")
		if [ "$output" == "TRUE" ]; then
			debug "bridge_add_int : Ensuring $int removed from $cur_br"
			output=$(command_execute "brctl delif $cur_br $int")
			output=$(lan_ifnames_reset "$cur_br")
		fi
	done

	## Now we can finally add the interface to the bridge, knowing it's not
	##  already there and it's not in other bridges
	debug "bridge_add_int : Adding $int to $bridge"
	output=$(command_execute "brctl addif $bridge $int")
	res=$?
	if [ "$output" == "FAIL" ]; then
		echo FAIL
		return 1
	else
		echo "SUCCESS"
		return 0
	fi
}
	
## Ensure we have all the tagged ports we want in a specific bridge for a VLAN
##
## tagged_ports "<port list>" "<bridge>" "<vlan>"
tagged_ports(){
	local ports="$1"
	local bridge="$2"
	local vlan="$3"
	local output
	local res
	local port
	local tagged_port

	debug "tagged_ports called with ports \"$ports\" bridge \"$bridge\" vlan \"$vlan\""
	## Make sure we have the data we need to proceed
	if [ -z "$ports" -o -z "$bridge" -o -z "$vlan" ]; then
		error "tagged_ports : ports, bridge, and vlan must be specified"
		echo "FAIL"
		return 1
	fi

	## Normalize the port list to remove extra white space and commas
	ports=$(normalize_ports "$ports")
	for port in $ports; do
		debug "tagged_ports : looking at $port in $bridge for $vlan"
		tagged_port="${port}.${vlan}"

		#### WE DO THIS IN bridge_add_int now
		## See if this port is already tagged in the bridge
		#debug "tagged_ports : Checking if $tagged_port is in $bridge"
		#output=$(bridge_has_int "$bridge" "$tagged_port")
		#if [ "$output" == "TRUE" ]; then
		#	debug "$tagged_port already in $bridge"
		#	continue
		#fi
	
		## If we don't have a tagged interface in the bridge, see if
		## this interface has been defined
		debug "tagged_ports : calling tagged_interface_create with port \"$port\" and vlan \"$vlan\""
		output=$(tagged_interface_create "$port" "$vlan")
		if [ "$output" == "FAIL" ]; then
			error "tagged_ports : tagged_interface_create failed - cannot proceedd without taged ints"
			exit
		fi

		## Add the interface to the bridge 
		##
		## Note - bridge_add_int will remove the interface from any other bridge it's in
		debug "tagged_ports : calling bridge_add_int with \"$bridge\" and \"$tagged_port\""
		output=$(bridge_add_int "$bridge" "$tagged_port")

	done
	echo "SUCCESS"
	return 0
}

## Setup untagged ports
##
## These are ports that will be taken out of the default bridge (br0) and put into
## the specified bridge.  The expecation is that bridge also has a tagged port	wich is linked
## to an upstream device that knows what to do with the VLAN traffic. 
##
## untagged_ports "<port list>" "<bridge>"
untagged_ports(){
	local ports="$1"
	local bridge="$2"
	local output
	local res
	local port
	local list
	local cur_br

	debug "untagged_ports : called with ports \"$ports\" and bridge \"$bridge\""

	## Make sure we have the data we need to proceed
	if [ -z "$ports" -o -z "$bridge" ]; then
		error "untagged_ports : both ports and bridge must be specified"
		echo "FAIL"
		return 1
	fi

	debug "untagged_ports : normalizing port list \'$ports\'"

	## Normalize the port list to remove extra white space and commas
	ports=$(normalize_ports "$ports")

	## For every port int he list, add it to the desired bridge.
	## Note, bridge_add_int handles removing the port from any bridge it's currently assigned to
	for port in $ports; do
		debug "untagged_ports : calling bridge_add_int with bridge \"$bridge\" and port \"$port\""
		output=$(bridge_add_int "$bridge" "$port")
		if [ "$output" == "FAIL" ]; then
			error "untagged_ports : could not add port \"$port\" to bridge \"$bridge\""
		fi
	done
}

## Get a list of interfaces associated with a specific SSID
##
## This is done by looking at the NVRAM settings for the SSID and finding the interfaces
## 
## wifi_get_ints_by_ssid <ssid>
wifi_get_ints_by_ssid(){
	local ssid="$1"
	local list

	## Make sure we have what we need to run
	if [ -z "$ssid" ]; then
		error "wifi_get_ints_by_ssid : ssid  opt cannot be null!"
		echo "FAIL"
		return 1
	fi

	## Pull data from NVRAM
	debug "wifi_get_ints_by_ssid : nvram show 2>&1 | grep \"_ssid=${ssid}\" | sed -e 's/_ssid=.*//' | tr '\n' ' '"
	list=$(nvram show 2>&1 | grep "_ssid=${ssid}" | sed -e 's/_ssid=.*//' | tr '\n' ' ')
	debug "wifi_get_ints_by_ssid : got list - $list"

	## Return the list of interfaces
	echo $list
	return 0
}

## Get a list of interfaces associated with a specific bridge
##
## This is needed to reset the lanX_ifnames settings in NVRAM
## bridge_get_ints <bridge>
bridge_get_ints(){
	local bridge="$1"
	local list

	## Make sure we have what we need to run
	if [ -z "$bridge" ]; then
		error "bridge_get_ints : bridge opt cannot be null!"
		echo "FAIL"
		return 1
	fi

	## Get the list of interfaces in the bridge
	list=$(brctl show $bridge | awk '{print $NF}' | grep -v interfaces | tr '\n' ' ')
	## Return the list of interfaces
	echo $list
	return 0
}

## $output=$(wifi_config "$VLAN_ID" "$BRIDGE_INT" "$LAN_IFNAME" "$WIFI_SSID")
## Ironic that my comment for this function was a copy and paste of a stupid error it took
##  twenty minutes to find.  Kept for posterity.
## 
## Reconfigure interfaces attached to SSIDs defined in config with associated VLANs.
## 
## Because ASUS reconfigures it's own stuff based on varius lanX_ifnames settings, we
##  we have to make sure we take care of those, too.
##
## wifi_config <vlan> <bridge> <lan_ifname> <wifi_ssid>
wifi_config(){
	local vlan="$1"
	local bridge="$2"
	local lan_ifname="$3"
	local wifi_ssid="$4"
	local wifi_ints
	local cur_int
	local output
	local changed

	changed=0

	## Make sure we were passed all the data we need to take action
	debug "wifi_config : called with vlan \"$vlan\" bridge \"$bridge\" lan_ifname \"$lan_ifname\" ssid \"$wifi_ssid\""
	if [ -z "$vlan" -o -z "$bridge" -o -z "$lan_ifname" -o -z "$wifi_ssid" ]; then
		debug "wifi_config : vlan, bridge, lan_ifname, and wifi_ssid cannot be null!"
		echo "FAIL"
		return 1
	fi

	## get list of wifi interfaces
	##
	## given we know the SSID we want to modify, we need to find the interfaces ASUS
	##  associated with those SSIDs.
	debug "wifi_config calling wifi_get_ints_by_ssid \"$wifi_ssid\""
	wifi_ints=$(wifi_get_ints_by_ssid "$wifi_ssid")
	debug "wifi_config : Got list of wifi Ints for $wifi_ssid - $wifi_ints"
	if [ "$wifi_ints" == "FAIL" ]; then
		error "wifi_config : no wifi ints found for ssid $wifi_ssid"
		echo FAIL
		return 1
	fi

	## move each interface to the right bridge
	##
	## default configuration puts all the Wireless networks on the same bridge
	##  - we need to reassign them to the bridges we want, with the right VLAN setups.
	for cur_int in $wifi_ints; do
		debug "wifi_config : Calling bridge_add_int \"$bridge\" \"$cur_int\""
		output=$(bridge_add_int "$bridge" "$cur_int")
		if [ "$output" == "FAIL" ]; then
			error "wifi_config : could not att $cur_int to $bridge.  bridge_add_int errored out"
		elif [ "$output" == "SUCCESS" ]; then
			## if we added an interface to the bridge, we need to note that
			## so we can return a value sufficient to restart EAPD
			debug "wifi_config : we saw a change"
			changed=1
		fi
	done

	## if we changed something, reset the nvram lanX_ifnames settings
	if [ "$changed" -eq 1 ]; then
		# get list of bridge interfaces
		output=$(bridge_get_ints "$bridge")
		# reset lanX_ifnames to list of bridge interfaces
		if [ ! -z "$output" -a "$output" != "FAIL" ]; then
			echo placeholder
			command_log "nvram set \"${lan_ifname}_ifnames\"=\"$output\""
			nvram set "${lan_ifname}_ifnames"="$output"
		fi
		command_log "nvram set \"${lan_ifname}_ifname\"=\"$bridge\""
		nvram set "${lan_ifname}_ifname"="$bridge"
		echo "SUCCESS"
	else
		echo "NOCHANGE"
	fi
}	

## Restart EAPD after Wifi Changes
##
## This should work in command_execute so things get logged, but it causes
##  things to hang - probably because eapd daemonizes, but have to debug.
##
## restart_eapd
restart_eapd(){

	# restart eapd
	debug "eapd_restart : killing EAPD"
	command_execute "killall eapd"
	sleep 3
	debug "eapd_restart : starting EAPD"
	# doesn't not like my command wrapper
	/bin/eapd

	# restart eapd
	echo "SUCCESS"
}

## We need to know if we changed WIFI related interfaces, so we know
##  if we need to restart EAPD or not, later.
WIFI_CHANGED=0

## Start of script.  For every configuration file, load it's data and use 
##  those definitions to to reconfigure our bridge / tagged int settings.
##
## Note - need to improve the selection of configuration files so we only 
##  load relevant things (not every file/dir that exists)
message "$0 - Started at $(date)"
for config in $(ls "${etc}/vlantt.d"); do
	## unset the variables set in config files so we don't mix in 
	##  data from the last iteration
	unset VLAN_ID
	unset BRIDGE_INT
	unset LAN_IFNAME
	unset PORTS_TAGGED
	unset PORTS_UNTAGGED
	unset WIFI_SSID
	unset WIFI_SSID_LIST

	## Load the configuration file
	message "working on \"${config}\""
	. "${etc}/vlantt.d/${config}"

	## Find and validate configuration
	if [ -z "$VLAN_ID" -o -z "$BRIDGE_INT" ]; then
		## VLAN_ID and BRIDGE_INT are required fore any permutation of the configuration
		echo "Information needed is not set in $config:"
		echo "  -> VLAN_ID must be set to the VLAN ID required"
		echo "  -> BRIDGE_INT must be set to the "brX" name for the bridge to use"
		echo
		## Everything else may be required depending on the action we are taking. 
		echo "Additionally, the following may be included:"
		echo "  -> PORTS_TAGGED must be set to the physical ports to tag (comma separated)"
		echo "  -> PORTS_UNTAGGED - comma separated list of untagged ports to include"
		echo "  -> WIFI_SSID - the SSID of a wifi network to inlcude"
		echo "  -> LAN_IFNAME must be set to the "lanX" name for the lanX_ifnames variable"
		echo "     This is required if WIFI_SSID is set"
		exit
	fi
	LAN_IFNAME=$(make_lan_ifname "$BRIDGE_INT")
	if [ "$LAN_IFNAME" == "FAIL" ]; then
		error "main : Could not make LAN _ifname name from $BRIDGE_INT"
		exit 1
	fi
	echo 
	echo "LAN_IFNAME NOW $LAN_IFNAME"
	echo
	## Does the bridge exist
	debug "main: Making bridge if it does not exist"
	if [ $(bridge_exists "$BRIDGE_INT") == "FALSE" ]; then
		debug "Making Bridge $BRIDGE_INT"
		output=$(bridge_create "$BRIDGE_INT")
		if [ "$output" == "FAIL" ]; then
			error "Could not create bridge $BRIDGE_INT"
			exit 1
		fi
	fi

	# We have the data we need to create tagged ports
	if [ ! -z "$VLAN_ID" -a ! -z "$BRIDGE_INT" -a ! -z "$PORTS_TAGGED" ]; then
		## Create / Add Tagged Ints
		debug "main : calling tagged_ports with tagged ports  \"$PORTS_TAGGED\" for bridge \"$BRIDGE_INT\" on VLAN \"VLAN_ID\""
		output=$(tagged_ports "$PORTS_TAGGED" "$BRIDGE_INT" "$VLAN_ID")
		if [ "$output" == "FAIL" ]; then
			error "main : tagged_ports returned failure"
			exit
		fi
	else
		## If we could not work with the configuration, note what was missing
		debug "main : Not processing tagged ports because: "
		debug "       $config settings contain insufficient iformation"
		debug "       VLAN_ID        -> $VLAN_ID"
		debug "       BRIDGE_INT     -> $BRIDGE_INT"
		debug "       PORTS_TAGGED   -> $PORTS_TAGGED"
	fi

	## Assign untagged Ports
	if [ ! -z "$VLAN_ID" -a ! -z "$BRIDGE_INT" -a ! -z "$PORTS_UNTAGGED" ]; then
		debug "main : calling untagged_ports with ports \"$PORTS_UNTAGGED\" and bridge \"$BRIDGE_INT\""
		output=$(untagged_ports "$PORTS_UNTAGGED" "$BRIDGE_INT")
		if [ "$	output" == "FAIL" ];then
			error "main : untagged_ports returned failure"
		fi
	else 
		## If we could not work with the configuration, note what was missing
		debug "main : Not processing untagged ports because: "
		debug "       $config settings contain insufficient iformation"
		debug "       VLAN_ID        -> $VLAN_ID"
		debug "       BRIDGE_INT     -> $BRIDGE_INT"
		debug "       PORTS_UNTAGGED -> $PORTS_UNTAGGED"
	fi

		
	## Deal with re-assigning Wifi interfaces as needed
	if [ ! -z "$VLAN_ID" -a ! -z "$BRIDGE_INT" -a ! -z "$LAN_IFNAME" -a ! -z "$WIFI_SSID" ]; then
		debug "main : calling wifi_config with vlan \"$VLAN_ID\", bridge \"$BRIDGE_INT\", lan_ifname \"$LAN_IFNAME\", and SSID \"$WIFI_SSID\""
		output=$(wifi_config "$VLAN_ID" "$BRIDGE_INT" "$LAN_IFNAME" "$WIFI_SSID")
		debug "main : wifi_config returns \"$output\""
		if [ "$output" == "FAIL" ]; then
			error "main : wifi_config returned failure:"
		elif [ "$output" == "SUCCESS" ]; then
			WIFI_CHANGED=1
		else
			debug "main : wifi_config returned no change"
		fi
	else
		## If we could not work with the configuration, note what was missing
		debug "main : not processing wifi config because: "
		debug "       $config settings contain insufficient iformation"
		debug "       VLAN_ID        -> $VLAN_ID"
		debug "       BRIDGE_INT     -> $BRIDGE_INT"
		debug "       WIFI_SSID      -> $WIFI_SSID"
	fi

	## validate lan_ifname is relfective of br0
	output=$(bridge_get_ints "br0")
	current=$(nvram get lan_ifnames)
	debug "main: lan_ifnames and br0 membership not in agreement - reseting lan_ifnames"
	if [ "$output" != "$current" ]; then
		command_log "nvram set lan_ifnames=\"$output\""
		nvram set lan_ifnames="$output"
	fi

done

## If we changed wifi things, restart EAPD.  
##  Sadly, I don't know why we do this - found it in others' documentation but no one documented
##  what EAPD is / does / why it's needed.  That's on the list to figure out.
if [ "$WIFI_CHANGED" -eq 1 ]; then
	wl -i eth5 down
	wl -i eth6 down
	sleep 5
	output=$(bridge_get_ints "br0")
	nvram set lan_ifnames="$output"
	restart_eapd
	sleep 5
	wl -i eth5 up
	wl -i eth6 up
else
	debug "main: Wifi not changed, not restarting EAPD"
fi

## Dump extra information if we are testing
if [ "$VLAN_TT_TESTING" -eq 1 ]; then
	nvram show | grep -E "lan.?_ifname.?"
fi
